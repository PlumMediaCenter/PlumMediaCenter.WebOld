angular.module('app', ['ui.router', 'ui.bootstrap', 'infinite-scroll'])
        .run(['$rootScope', 'enums', 'globals', function($rootScope, enums, globals) {
                $rootScope.enums = enums;
                $rootScope.globals = globals;
            }]);

fetchConstants().then(bootstrapApplication);


/**
 * Load constants asynchronously BEFORE bootstrapping the application
 * @returns {unresolved}
 */
function fetchConstants() {
    var injector = angular.injector(["ng"])
    var $http = injector.get("$http");
    var $q = injector.get('$q');

    var promises = [
        $q(function(resolve, reject) {
            $http.get('api/GetEnumerations.php').then(function(result) {
                angular.module('app').constant("enums", result.data);
                resolve();
            }, reject);
        })
    ];

    return $q.all(promises);
}

function bootstrapApplication() {
    angular.element(document).ready(function() {
        angular.bootstrap(document, ["app"]);
    });
}
angular.module('app')
        .config(['$stateProvider', '$urlRouterProvider',
            function($stateProvider, $urlRouterProvider) {
                $urlRouterProvider.otherwise('/home');

                $stateProvider
                        .state('home', {
                            url: '/home',
                            templateUrl: 'app/partials/home.html',
                            controller: 'HomeController',
                            controllerAs: 'vm'
                        })
                        .state('admin', {
                            url: '/admin',
                            templateUrl: 'app/partials/admin.html',
                            controller: 'AdminController',
                            controllerAs: 'vm'
                        })
                        .state('videoInfo', {
                            url: '/videoInfo/{videoId:int}',
                            templateUrl: 'app/partials/videoInfo.html',
                            controller: 'VideoInfoController',
                            controllerAs: 'vm'
                        })
                        .state('videoSources', {
                            url: '/videoSources',
                            templateUrl: 'app/partials/videoSources.html',
                            controller: 'VideoSourcesController',
                            controllerAs: 'vm'
                        })
                        .state('editVideoSource', {
                            url: '/editVideoSource/{id:int}',
                            parent: 'videoSources',
                            templateUrl: 'app/partials/editVideoSource.html',
                            controller: 'EditVideoSourceController',
                            controllerAs: 'vm'
                        })
                        .state('play', {
                            url: '/play/{videoId:int}?{showVideoId:int}',
                            templateUrl: 'app/partials/play.html',
                            controller: 'PlayController',
                            controllerAs: 'vm'
                        })
                        .state('search', {
                            url: '/search?q',
                            templateUrl: 'app/partials/search.html',
                            controller: 'SearchController',
                            controllerAs: 'vm'
                        })
                        .state('metadataFetcher', {
                            url: '/metadataFetcher/{videoId:int}',
                            templateUrl: 'app/partials/metadataFetcher.html',
                            controller: 'MetadataFetcherController',
                            controllerAs: 'vm'
                        }) 
            }])

        .run(['$rootScope', '$state', '$stateParams', function($rootScope, $state, $stateParams) {
                $rootScope.$state = $state;
                $rootScope.$stateParams = $stateParams;
            }])
angular.module('app').controller('AdminController', ['$timeout', '$window', 'globals', 'api', 'notify', 'Video', 'admin',
    function($timeout, $window, globals, api, notify, Video, admin) {
        globals.title = 'Admin';

        var vm = angular.extend(this, {
            //properties
            serverVersionNumber: undefined,
            //api
            fetchMissingMetadata: fetchMissingMetadata,
            generateLibrary: generateLibrary,
            updateApplication: updateApplication
        });


        getVideoCounts();
        getServerVersionNumber();

        function generateLibrary() {
            var n = notify('Generating library', 'info');
            globals.generateLibraryIsPending = true;
            api.generateLibrary().then(function() {
                notify('Library has been generated', 'success');
            }).catch(function(err) {
                notify('There was an error generating the library: "' + err.message + '"', 'danger');
            }).finally(function() {
                globals.generateLibraryIsPending = false;
                getVideoCounts();
            });
        }

        function getServerVersionNumber() {
            admin.getServerVersionNumber().then(function(version) {
                vm.serverVersionNumber = version;
            });
        }
        function getVideoCounts() {
            Video.getCounts().then(function(videoCounts) {
                vm.videoCounts = videoCounts;
            });
        }

        function fetchMissingMetadata() {
            globals.fetchMissingMetadataIsPending = true;
            notify('Fetching missing metadata', 'info');
            Video.fetchMissingMetadata().then(function() {
                notify('Finished fetching missing metata for videos', 'success');
            }, function() {
                notify('There was an error fetching missing metadata', 'error');
            }).finally(function() {
                globals.fetchMissingMetadataIsPending = false;
            });
        }

        function updateApplication() {
            globals.checkForUpdatesIsPending = true;
            notify('Checking for updates. Please wait until this operation has completed', 'info');
            admin.updateApplication().then(function(result) {
                if (result.updateWasApplied) {
                    notify('Application has been updated. Reloading page.', 'success');
                    $timeout(function() {
                        $window.location.reload();
                    }, 4000);
                } else {
                    notify('No updates were found', 'success');
                }
            }, function() {
                notify('Unable to check and install updates', 'error');
            }).finally(function() {
                globals.checkForUpdatesIsPending = false;
            });
        }
    }]);
angular.module('app').controller('BaseController', ['globals',function(globals) {
        var vm = angular.extend(this, {
            globals: globals
        });
        
    }]);
angular.module('app').controller('EditVideoSourceController', ['$scope', 'globals', 'VideoSource', '$stateParams', 'enums',
    function($scope, globals, VideoSource, $stateParams, enums) {
        globals.title = 'Edit Video Source';
        var vm = this;
        vm.reset = reset;
        vm.save = save;
        vm.videoSource = {
            securityType: enums.securityType.public
        };
        vm.originalVideoSource = angular.copy(vm.videoSource);
        loadVideoSource();

        function loadVideoSource() {
            //if an id was provided, go look up the settings for that videoSource
            if ($stateParams.id && $stateParams.id > 0) {
                vm.loading = true;
                VideoSource.getById($stateParams.id).then(function(videoSource) {
                    vm.videoSource = videoSource;
                    vm.originalVideoSource = angular.copy(videoSource);
                }).finally(function() {
                    vm.loading = false;
                });
            }
        }

        function reset() {
            vm.videoSource = vm.originalVideoSource;
            vm.form.setPristine(true);
        }

        function save() {
            VideoSource.save(vm.videoSource).then(function(videoSource) {
                loadVideoSource();
                vm.form.setPristine(true);
            }, function() {
                //handle the error

            });
        }

    }]);
angular.module('app').controller('EditVideoSourceController', ['$stateParams',
    function($stateParams) {
        var vm = angular.extend(this, {
            //properties
            title: undefined
                    //api

        });

        vm.title = $stateParams.title;

    }]);
angular.module('app').controller('HomeController', ['globals', 'Video', function(globals, Video) {
        var vm = angular.extend(this, {
            allVideos: [],
            currentlyLoadedVideos: [],
            //api
            loadMore: loadMore
        });
        globals.title = 'Home';

        Video.getAll().then(function(videos) {
            vm.allVideos = videos;
        });

        function loadMore() {
            var numberToLoad = globals.infiniteScrollPageSize;
            var beginIndex = vm.currentlyLoadedVideos.length;
            var endIndex = beginIndex + numberToLoad;
            //if the end index is larger than the list of all videos, change the end index to the length of the list of all videos
            endIndex = endIndex > vm.allVideos.length ? vm.allVideos.length : endIndex;

            for (var i = beginIndex; i < endIndex; i++) {
                vm.currentlyLoadedVideos.push(vm.allVideos[i]);
            }
        }

    }]);
angular.module('app').controller('MetadataFetcherController', ['$scope', '$q', 'globals', 'refreshImage', 'Video', '$state', '$stateParams', 'notify', 'enums',
    function($scope, $q, globals, refreshImage, Video, $state, $stateParams, notify, enums) {
        globals.title = 'Fetch Metadata';
        var vm = angular.extend(this, {
            searchByOptions: {
                onlineVideoId: 'onlineVideoId',
                title: 'title'
            },
            videoId: $stateParams.videoId,
            searchBy: 'onlineVideoId',
            isSearching: false,
            metadataIsBeingFetched: false,
            textboxLabel: undefined,
            //this is the value (title, onlineVideoId) to use to search for the metadata
            searchValue: undefined,
            searchResults: undefined,
            video: {},
            //api
            search: search,
            calculateTextboxLabel: calculateTextboxLabel,
            fetchMetadataByOnlineVideoId: fetchMetadataByOnlineVideoId
        });

        $scope.$watch('vm.searchBy', searchByChanged);

        $scope.$watch('vm.video', vm.calculateTextboxLabel);

        function searchByChanged() {
            vm.calculateTextboxLabel();
            if (vm.searchBy === vm.searchByOptions.title) {
                vm.searchValue = vm.video.title;
            } else {
                vm.searchValue = '';
            }
        }

        function calculateTextboxLabel() {
            vm.textboxLabel = undefined;

            if (!vm.video) {
                return;
            }
            if (vm.searchBy === vm.searchByOptions.title) {
                vm.textboxLabel = 'Title';
            } else {
                vm.textboxLabel = vm.video.mediaType === enums.mediaTypeMovie ? 'TMDB ID' : 'TVDB ID';
            }
        }

        //load the video
        Video.getById(vm.videoId).then(function(video) {
            angular.extend(vm.video, video);
            searchByChanged()
        });

        Video.getPathInfo(vm.videoId).then(function(video) {
            angular.extend(vm.video, video);
        });

        function search() {
            vm.isSearching = true;
            var promise;
            if (vm.searchBy === vm.searchByOptions.title) {
                promise = Video.getMetadataSearchResultsByTitle(vm.video.mediaType, vm.searchValue);
            } else {
                promise = Video.getMetadataSearchResultsByOnlineVideoId(vm.video.mediaType, vm.searchValue);
            }
            promise.then(function(searchResults) {
                vm.metadataResults = searchResults;
                vm.isSearching = false;
            });
        }

        function fetchMetadataByOnlineVideoId(onlineVideoId) {
            vm.metadataIsBeingFetched = true;
            Video.fetchMetadata(vm.video.videoId, onlineVideoId).then(function() {
                return Video.getById(vm.video.videoId);
            }).then(function(video) {
                //refresh the posters so that when we go back to videoInfo, the poster cache has been cleared
                return refreshImage(video.sdPosterUrl).then(function() {
                    return refreshImage(video.hdPosterUrl);
                }).then(function(){
                    //there was an issue getting the browser to refresh the cached images. try reloading the page (after we have 
                    //navigated to the videoInfo page)
                    setTimeout(function(){
                        window.location.reload();
                    }, 200);
                    return undefined;
                });
            }).then(function() {
                vm.metadataResults = undefined;
                vm.metadataIsBeingFetched = false;

                notify('Updated video with selected metadata', 'success');
                $state.go('videoInfo', {videoId: vm.videoId});
            })['catch'](function(err) {
                vm.metadataIsBeingFetched = false;
                notify('There was an error fetching metadata for the video you selected: ' + err, 'error');
            })
        }


    }]);
angular.module('app').controller('NavbarController', ['$state', function($state) {
        var vm = angular.extend(this, {
            searchTerm: undefined,
            navbarIsOpen: false,
            //api
            search: search,
            hideNavbar: hideNavbar,
            toggleNavbar: toggleNavbar
        });

        function search() {
            if (vm.searchTerm && vm.searchTerm.trim().length > 0) {
                $state.go('search', {q: vm.searchTerm});
                vm.searchTerm = undefined;
                hideNavbar();
            }
        }

        function showNavbar() {
            vm.navbarIsOpen = true;
        }

        function hideNavbar() {
            vm.navbarIsOpen = false;
        }

        function toggleNavbar() {
            vm.navbarIsOpen ? hideNavbar() : showNavbar();
        }

    }]);
angular.module('app').controller('PlayController', ['$scope', 'globals', '$stateParams', 'notify',
    function($scope, globals, $stateParams, notify) {
        globals.title = 'Play';
        globals.hideNavbar = true;
        
        var vm = angular.extend(this, {
            videoId: $stateParams.videoId,
            showVideoId: $stateParams.showVideoId
        });

        $scope.$on("$destroy", function() {
           globals.hideNavbar = false;
        });
    }]);
angular.module('app').controller('SearchController', ['globals', 'Video', '$stateParams', function(globals, Video, $stateParams) {
        var vm = angular.extend(this, {
            allVideos: [],
            currentlyLoadedVideos: [],
            searchTerm: $stateParams.q,
            //api
            loadMore: loadMore
        });

        globals.title = 'Home';
        var searchTerm = $stateParams.q;

        Video.search(searchTerm).then(function(videos) {
            vm.allVideos = videos;
        });


        function loadMore() {
            var numberToLoad = globals.infiniteScrollPageSize;
            var beginIndex = vm.currentlyLoadedVideos.length;
            var endIndex = beginIndex + numberToLoad;
            //if the end index is larger than the list of all videos, change the end index to the length of the list of all videos
            endIndex = endIndex > vm.allVideos.length ? vm.allVideos.length : endIndex;

            for (var i = beginIndex; i < endIndex; i++) {
                var video = vm.allVideos[i];
                vm.currentlyLoadedVideos.push(video);
            }
        }

    }]);
angular.module('app').controller('VideoInfoController', ['$scope', 'globals', 'Video', '$state', '$stateParams', 'enums',
    function($scope, globals, Video,$state,  $stateParams, enums) {
        var vm = angular.extend(this, {
            progressPercent: 0,
            preventCache: $stateParams.preventCache,
            episodes: undefined,
            videoId: $stateParams.videoId,
            //api
            getProgressPercentType: getProgressPercentType,
            navigateToShow: navigateToShow
        });
        globals.title = 'VideoInfo';

        $scope.$watch('vm.episodes', fetchAllEpisodePercentWatched);

        //load the video by id
        Video.getById(vm.videoId).then(function(video) {
            vm.video = video;

            if (vm.video.mediaType === enums.mediaType.show) {
                //get all of the episodes for this show
                Video.getEpisodes(vm.video.videoId).then(function(episodes) {
                    vm.episodes = episodes;
                    //find the next episode that should be watched
                }).then(function() {
                    return Video.getNextEpisode(vm.video.videoId);
                    //select the episode in our local list of episodes that matches the next episode
                }).then(function(nextEpisode) {
                    vm.nextEpisode = _.where(vm.episodes, {videoId: nextEpisode.videoId})[0];
                    //figure out how much of this episode has been watched
                }).then(function() {
                    return Video.getProgressPercent(vm.nextEpisode.videoId);
                    //save the percentWatched to the episode
                }).then(function(percent) {
                    vm.nextEpisode.percentWatched = percent;
                });
            }

            //load the progress of this video
            Video.getProgressPercent(vm.video.videoId).then(function(percent) {
                vm.progressPercent = percent;
            });

        })

        /**
         * Grabs the percent watched for every episode
         * @returns {undefined}
         */
        function fetchAllEpisodePercentWatched() {
            var videoIds = _.pluck(vm.episodes, 'videoId');
            Video.getProgressPercentMultiple(videoIds).then(function(percentObjects) {
                for (var i in percentObjects) {
                    var percentObj = percentObjects[i];
                    var episode = _.where(vm.episodes, {videoId: percentObj.videoId})[0];
                    if (episode) {
                        episode.percentWatched = percentObj.percent;
                    }
                }
            });
        }

        function getProgressPercentType() {
            if (vm.progressPercent < 40) {
                return'danger';
            } else if (vm.progressPercent < 99) {
                return 'warning';
            } else if (vm.progressPercent < 101) {
                return 'success';
            }
        }

        function navigateToShow() {
            Video.getShowFromEpisodeId(vm.videoId).then(function(show) {
                $state.go('videoInfo', {videoId: show.videoId});
            });
        }
    }]);
angular.module('app').controller('VideoSourcesController', ['globals', 'VideoSource', 'notify',
    function(globals, VideoSource, notify) {
        var vm = this;
        vm.editIsVisible = false;
        vm.deleteVideoSource = deleteVideoSource;
        vm.refresh = loadVideoSources;

        globals.title = 'Video Sources';
        loadVideoSources();
        
        function loadVideoSources() {
            VideoSource.getAll().then(function(videoSources) {
                vm.videoSources = videoSources;
            });
        }

        function deleteVideoSource(id) {
            VideoSource.deleteById(id).then(loadVideoSources);
        }
    }]);
angular.module('app').service('Video', ['$http', '$q', '_', function($http, $q, _) {
        function Video() {

        }

        Video.search = function(searchTerm) {
            var deferred = $q.defer();
            $http.get('api/GetSearchResults.php', {params: {q: searchTerm}}).success(function(data) {
                deferred.resolve(data);
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        };

        Video.getAll = function() {
            return $q(function(resolve, reject) {
                $http.get('api/GetLibrary.php').success(function(data) {
                    resolve(data);
                });
            });
        };

        Video.getById = function(id) {
            var deferred = $q.defer();
            if (!_.isNumber(id)) {
                deferred.reject();
            } else {
                $http.get('api/GetVideo.php?videoId=' + id).success(function(data) {
                    deferred.resolve(data);
                }).error(function() {
                    deferred.reject(data);
                });
            }
            return deferred.promise;
        };

        Video.getEpisodes = function(showId) {
            var deferred = $q.defer();
            $http.get('api/GetTvEpisodes.php?videoId=' + showId).success(function(data) {
                deferred.resolve(data);
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        };

        Video.getNextEpisode = function(showId) {
            var deferred = $q.defer();
            $http.get('api/GetNextEpisode.php?videoId=' + showId).success(function(data) {
                deferred.resolve(data);
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        };

        /**
         * Get how much percentage watched this video is
         * @param {type} videoId
         * @returns {$q@call;defer.promise}
         */
        Video.getProgressPercent = function(videoId) {
            var deferred = $q.defer();
            $http.get('api/GetVideoProgressPercent.php', {params: {videoId: videoId}})
                    .success(function(result) {
                        deferred.resolve(result.percent);
                    })
                    .error(deferred.reject);
            return deferred.promise;
        };

        /**
         * Get how much percentage watched each video is
         * @param {type} videoId
         * @returns {$q@call;defer.promise}
         */
        Video.getProgressPercentMultiple = function(videoIds) {
            videoIds = _.isArray(videoIds) ? videoIds : [];
            var deferred = $q.defer();
            $http.get('api/GetVideoProgressPercentMultiple.php', {
                params: {
                    videoIds: videoIds.join(',')
                }
            }).success(function(result) {
                deferred.resolve(result);
            }).error(deferred.reject);
            return deferred.promise;
        };

        /**
         * Get the number of seconds into a video the current user is. 
         * @param {type} videoId
         * @returns {$q@call;defer.promise}
         */
        Video.getProgress = function(videoId) {
            var deferred = $q.defer();
            $http.get('api/GetVideoProgress.php', {params: {
                    videoId: videoId
                }}).success(function(data) {
                deferred.resolve(data.startSeconds);
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        }

        Video.setProgress = function(videoId, seconds, isFinished) {
            isFinished = isFinished === true ? true : false;

            var deferred = $q.defer();
            $http.get('api/SetVideoProgress.php', {params: {
                    videoId: videoId,
                    seconds: seconds,
                    finished: isFinished
                }}).success(function(data) {
                if (data.success) {
                    deferred.resolve();
                } else {
                    deferred.reject();
                }
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        }

        Video.getCounts = function() {
            var deferred = $q.defer();
            $http.get('api/GetVideoCounts.php').success(function(data) {
                deferred.resolve(data);
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        };

        Video.fetchMetadata = function(videoId, onlineVideoId) {
            var deferred = $q.defer();
            $http.get('api/FetchVideoMetadata.php', {params: {videoId: videoId, onlineVideoId: onlineVideoId}}).success(function(data) {
                deferred.resolve(data);
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        };

        Video.getMetadataSearchResultsByTitle = function(mediaType, title) {
            var deferred = $q.defer();
            $http.get('api/GetMetadataSearchResults.php', {
                params: {
                    mediaType: mediaType,
                    title: title
                }
            }).success(function(data) {
                deferred.resolve(data);
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        }
        Video.getMetadataSearchResultsByOnlineVideoId = function(mediaType, onlineVideoId) {
            var deferred = $q.defer();
            $http.get('api/GetMetadataSearchResults.php', {
                params: {
                    mediaType: mediaType,
                    onlineVideoId: onlineVideoId
                }
            }).success(function(data) {
                deferred.resolve(data);
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        }

        Video.getPathInfo = function(videoId) {
            var deferred = $q.defer();
            $http.get('api/GetVideoPathInfo.php?videoId=' + videoId)
                    .success(function(video) {
                        deferred.resolve(video);
                    })
                    .error(function() {
                        deferred.reject();
                    });
            return deferred.promise;
        }

        Video.getShowFromEpisodeId = function(episodeId) {
            var deferred = $q.defer();
            $http.get('api/GetTvShowByEpisodeId.php?videoId=' + episodeId)
                    .success(function(video) {
                        deferred.resolve(video);
                    })
                    .error(function() {
                        deferred.reject();
                    });
            return deferred.promise;
        }

        /**
         * Finds a poster and metadata for every video in the library that does not have one yet.
         * @returns {$q@call;defer.promise}
         */
        Video.fetchMissingMetadata = function() {
            var deferred = $q.defer();
            $http.get('api/FetchMissingMetadataAndPosters.php')
                    .success(function(result) {
                        deferred.resolve(result);
                    })
                    .error(function() {
                        deferred.reject();
                    });
            return deferred.promise;
        }
        return Video;
    }]);
angular.module('app').service('VideoSource', ['$http', '$q', function($http, $q) {
        function VideoSource() {

        }

        VideoSource.getAll = function() {
            var deferred = $q.defer();
            $http.get('api/GetVideoSources.php').success(function(data) {
                deferred.resolve(data);
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        };

        VideoSource.getById = function(id) {
            var deferred = $q.defer();
            $http.get('api/GetVideoSourceById.php?id=' + id).success(function(data) {
                deferred.resolve(data);
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        };

        VideoSource.save = function(videoSource) {
            return $q(function(resolve, reject) {
                $http.post('api/PostVideoSource.php', videoSource).then(function(result) {
                    resolve(result.data);
                }, reject);
            });
        };

        VideoSource.deleteById = function(id) {
            return $q(function(resolve, reject) {
                $http.delete('api/DeleteVideoSource.php', {data: {id: id}}).then(function(result) {
                    resolve(result.data);
                }, reject);
            });
        };

        return VideoSource;
    }]);
angular.module('app').service('admin', ['$http', '$q', '_', function($http, $q, _) {
        return {
            getServerVersionNumber: getServerVersionNumber,
            updateApplication: updateApplication
        };

        /**
         * Finds a poster and metadata for every video in the library that does not have one yet.
         * @returns {$q@call;defer.promise}
         */
        function getServerVersionNumber() {
            var deferred = $q.defer();
            $http.get('api/GetServerVersionNumber.php')
                    .success(function(result) {
                        deferred.resolve(result);
                    })
                    .error(function() {
                        deferred.reject();
                    });
            return deferred.promise;
        }

        /**
         * Checks for updates to this application and updates if there are any.
         * @returns {undefined}
         */
        function updateApplication() {
            var deferred = $q.defer();
            $http.get('api/Update.php')
                    .success(function(result) {
                        if (result.success === true) {
                            deferred.resolve(result);
                        } else {
                            deferred.reject(result);
                        }
                    })
                    .error(function(err) {
                        deferred.reject(err);
                    });
            return deferred.promise;
        }
    }]);
angular.module('app').service('api', ['$q', '$http', function($q, $http) {
        return {
            generateLibrary: generateLibrary
        };

        function generateLibrary() {
            return $q(function(resolve, reject) {
                $http.get('api/GenerateLibrary.php')
                        .success(function(result) {
                            if (result.success) {
                                resolve();
                            } else {
                                reject();
                            }
                        })
                        .error(function() {
                            reject();
                        })

            });
        }
    }]);
angular.module('app').service('globals', [function() {
        return {
            pageTitle: 'PlumMediaCenter',
            hideNavbar: false,
            infiniteScrollPageSize: 25,
            //whenever the admin page launches a metadata fetch, keep track of its status here. 
            fetchMissingMetadataIsPending: false,
            generateLibraryIsPending: false,
            checkForUpdatesIsPending: false
        };
    }]);
angular.module('app').service('_', function(){
    return window._;
});
angular.module('app').service('notify', function() {
    return notify;
});

 function notify(message, type) {
        type = type ? type : 'warning';
        //if danger was provided, convert to error
        type = type === 'danger' ? 'error' : type;
        
        return new PNotify({
            title: '',
            text: message,
            styling: 'bootstrap3',
            type: type
        });
    }
/**
 * Takes an image url and refreshes that image so that the browser cache can be refreshed
 * @param {type} param1
 * @param {type} param2
 */
angular.module('app').service('refreshImage', ['$q', function($q) {
        function refreshImage(uri) {
            var deferred = $q.defer();
            var reload = function() {
                // Force a reload of the iframe
                this.contentWindow.location.reload(true);

                // Remove `load` event listener and remove iframe
                this.removeEventListener('load', reload, false);
                this.parentElement.removeChild(this);

               deferred.resolve();
            };

            var iframe = document.createElement('iframe');
            iframe.style.display = 'none';

            // Reload iframe once it has loaded
            iframe.addEventListener('load', reload, false);

            // Only call callback if error occured while loading
            iframe.addEventListener('error', deferred.reject, false);
            iframe.src = uri;
            document.body.appendChild(iframe);
            return deferred.promise;
        }

        return refreshImage;
    }]);
angular.module('app').service('uniqueId', [function() {
        var counter = 0;
        return function() {
            counter++;
            return 'element-' + counter;
        }
    }]);
angular.module('app').service('util', ['_', function(_) {
        return {
            blankItemInPlace: blankItemInPlace
        };

        function blankItemInPlace(item) {
            if (_.isArray(item)) {
                while (item.length > 0) {
                    item.pop();
                }
            } else {
                for (var i in item) {
                    delete item[i];
                }
            }
        }
    }]);
angular.module('app').directive('confirm', [function() {
        return {
            restrict: 'A',
            link: function(scope, element, attributes, controller) {
                element.on('click', function() {
                    var message = scope.$eval(attributes.confirmMessage);
                    message = message? message: 'Are you sure you want to do that?';
                    //show the confirm modal
                    var confirmed = confirm(message);
                    if (confirmed) {
                        scope.$eval(attributes.confirm);
                    }
                });
            }
        }

    }]);
angular.module('app').directive('focus', ['$timeout', '$parse', function($timeout, $parse) {
        return {
            restrict: 'A',
            link: function($scope, element, attributes, controller) {
                $scope.$watch(function() {
                    return $scope.$eval(attributes.focus);
                }, function(focus) {
                    if (focus === true) {
                        $timeout(function() {
                            element[0].focus();
                            getter = $parse(attributes.focus);
                            //override the value with a false now that we have performed the focus
                            getter.assign($scope, false);
                        });
                    }
                });
            }
        }

    }]);
angular.module('app').directive('jwplayer', ['uniqueId', function(uniqueId) {
        return {
            restrict: 'E',
            replace: true,
            controllerAs: 'vm',
            controller: ['Video', '$scope', 'util', Controller],
            bindToController: true,
            scope: {
                videoId: '='
            },
            link: function(scope, element, attributes, vm) {
                vm.elementId = element.attr('id');
                vm.playlist = [{file: 'http://localhost:8080/videos/movies/A%20Good%20Day%20to%20Die%20Hard/A%20Good%20Day%20to%20Die%20Hard.mp4'}];
                if (!vm.elementId) {
                    vm.elementId = uniqueId();
                }

                element.attr('id', vm.elementId);

                //TODO - implement the keyboard shortcuts
                function keyboardShortcuts(e) {
                    switch (e.which) {
                        case 32://spacebar key
                            //toggle playback
                            jwplayer().play();
                            break;
                        case 70: //f key
                            //toggle fullscreen
                            if (player.getFullscreen() === true) {
                                player.setFullscreen(false);
                            } else {
                                player.setFullscreen(true);
                            }
                            break;
                        case 39: //right arrow key
                            //seek forward n seconds
                            var position = player.getPosition();
                            var newPosition = position + seekBurstSeconds;
                            if (position <= seekPosition) {
                                newPosition = seekPosition + seekBurstSeconds;
                            }
                            seekPosition = newPosition;
                            player.seek(seekPosition);
                            break;
                        case 37: //left arrow key
                            //seek backwards n seconds
                            var position = player.getPosition();
                            var newPosition = position - seekBurstSeconds;
                            if (position >= seekPosition) {
                                newPosition = seekPosition - seekBurstSeconds;
                            }
                            seekPosition = newPosition;
                            player.seek(seekPosition);
                            break;
                    }
                }
            },
            template: '<div class="jwplayer"></div>'
        }

        function Controller(Video, $scope, util) {
            var vm = this;
            angular.extend(this,
                    {
                        play: play,
                        pause: pause,
                        playlist: [],
                        loadVideo: loadVideo,
                        togglePlayback: togglePlayback
                    }
            );
            var startSeconds = 0;
            //keeps track of the number of seconds that have passed since the video has saved its position in the database
            var playPositionUpdateTime = new Date();

            //load the video
            Video.getById(vm.videoId).then(function(video) {
                //get the current progress of this video.
                Video.getProgress(vm.videoId).then(function(seconds) {
                    vm.video = video;
                    startSeconds = seconds;
                });
            });

            $scope.$watch('vm.video', vm.loadVideo);

            //when the directive is removed, remove the jwplayer from the page
            $scope.$on('$destroy', function() {
                jwplayer(vm.elementId).remove();
            });

            /**
             * Toggles the play/pause state. if playing, the player pauses. if paused, the player plays.
             */
            function togglePlayback() {
                vm.player.play();
            }

            /**
             * Tells the player to play. If already playing, playback continues. 
             * if paused, the player starts playing.
             */
            function play() {
                vm.player.play(true);
            }

            /**
             * Pauses the player. If the player is playing, playback is paused. 
             * if the player is paused, the player stays paused.
             */
            function pause() {
                vm.player.pause(false);
            }

            function loadVideo(video) {
                //empty the playlist 
                util.blankItemInPlace(vm.playlist);
                if (!video) {
                    return;
                }
                //add the video to the playlist
                vm.playlist.push({
                    file: video.url,
                    image: video.posterUrl,
                    title: video.title,
                    video: video
                });

                if (vm.jwplayer) {
                    vm.player.load(vm.playlist);
                } else {
                    //the jwplayer has not yet been created, create it now
                    jwplayer(vm.elementId).setup({
                        flashplayer: 'lib/jwplayer-6.11/jwplayer.flash.swf',
                        primary: 'html5',
                        playlist: vm.playlist,
                        startparam: 'start',
                        wmode: 'transparent',
                        width: '100%',
                        height: '100%',
                        events: {
                            onTime: onTime,
                            onPlay: onPlay,
                            onComplete: onComplete
                        },
                        autostart: true
                    });
                    vm.player = jwplayer(vm.elementId);
                }
            }

            var startVideoWhereWeLeftOffProcessed = false;
            /**
             * Event that is called every time the video changes time position. This may be called up to 
             * 10 times a second
             */
            function onTime(obj) {
                if (startVideoWhereWeLeftOffProcessed === false && obj.position > 0) {
                    startVideoWhereWeLeftOffProcessed = true;
                    startVideoWhereWeLeftOff();
                    return;
                }

                var positionInSeconds = obj.position;
                //every so often, update the database with the current video's play position
                var nowTime = new Date();
                var timeSinceLastUpdate = nowTime - playPositionUpdateTime;
                if (timeSinceLastUpdate > 5000) {
                    playPositionUpdateTime = new Date();
                    Video.setProgress(vm.video.videoId, positionInSeconds);
                }
            }
            
            function onComplete(){
                console.debug('Finished playing video ' + vm.video.videoId);
                Video.setProgress(vm.video.videoId, -1, true);
            }

            /**
             * Seeks to the playback position indicated by the database. This should only be called ONCE, 
             * and only after the video has started playing
             */
            function startVideoWhereWeLeftOff() {
                //seek the player to the startPosition
                //if a startSeconds value greater than 0 was provided, seek to that position in the video
                if (startSeconds > 0) {
                    vm.player.seek(startSeconds);
                    console.debug('seeking to ', startSeconds);
                }
            }

            /**
             * Event that is fired every time the video starts playing
             */
            function onPlay() {
                playPositionUpdateTime = new Date();
            }

        }
    }]);
angular.module('app').directive('videoTile', [function() {
        return {
            restrict: 'E',
            controllerAs: 'vm',
            controller: [Controller],
            bindToController: true,
            scope: {
                video: '='
            },
            templateUrl: 'app/directives/videoTileDirective.html'
        }

        function Controller() {
            
        }
    }]);
angular.module('app').directive('pathExistsValidator', function($http, $q) {
    return {
        require: 'ngModel',
        link: function(scope, element, attrs, ngModel) {
            ngModel.$asyncValidators.pathExists = function(modelValue, viewValue) {
                var value = modelValue || viewValue;
                return $http.get('api/GetPathExistsOnServer.php', {params: {path: value}}).then(
                        function(response) {
                            if (!response.data.exists === true) {
                                return $q.reject(response.data.errorMessage);
                            }
                            return true;
                        }
                );
            };
        }
    };
});
angular.module('app').directive('urlExistsValidator', function($http, $q) {
    return {
        require: 'ngModel',
        link: function(scope, element, attrs, ngModel) {
            ngModel.$asyncValidators.urlExists = function(modelValue, viewValue) {
                var value = modelValue || viewValue;
                return $http.get('api/GetUrlExists.php', {params: {url: value}}).then(
                        function(response) {
                            if (!response.data.exists === true) {
                                return $q.reject(response.data.errorMessage);
                            }
                            return true;
                        }
                );
            };
        }
    };
});