angular.module('app', ['ui.router', 'ui.bootstrap', 'infinite-scroll', 'ngTouch', 'ngAnimate'])
    .run(['$rootScope', 'enums', 'globals', function ($rootScope, enums, globals) {
        $rootScope.enums = enums;
        $rootScope.globals = globals;
    }]);

fetchConstants().then(bootstrapApplication);


/**
 * Load constants asynchronously BEFORE bootstrapping the application
 * @returns {unresolved}
 */
function fetchConstants() {
    var injector = angular.injector(["ng"])
    var $http = injector.get("$http");
    var $q = injector.get('$q');

    var promises = [
        $q(function (resolve, reject) {
            $http.get('api/GetEnumerations.php').then(function (result) {
                angular.module('app').constant("enums", result.data);
                resolve();
            }, reject);
        })
    ];

    return $q.all(promises);
}

function bootstrapApplication() {
    angular.element(document).ready(function () {
        angular.bootstrap(document, ["app"]);
    });
}
angular.module('app')
    .config(['$stateProvider', '$urlRouterProvider',
        function ($stateProvider, $urlRouterProvider) {
            $urlRouterProvider.otherwise('/home');

            $stateProvider
                .state('addNewMediaItem', {
                    url: '/addNewMediaItem',
                    templateUrl: '/addNewMediaItem.html',
                    controller: 'AddNewMediaItemController',
                    controllerAs: 'vm'
                })
                .state('home', {
                    url: '/home',
                    templateUrl: '/home.html',
                    controller: 'HomeController',
                    controllerAs: 'vm'
                })
                .state('categories', {
                    url: '/categories/:categoryName',
                    templateUrl: '/categories.html',
                    controller: 'CategoriesController',
                    controllerAs: 'vm'
                })
                .state('admin', {
                    url: '/admin',
                    templateUrl: '/admin.html',
                    controller: 'AdminController',
                    controllerAs: 'vm'
                })
                .state('videoInfo', {
                    url: '/videoInfo/{videoId:int}',
                    templateUrl: '/videoInfo.html',
                    controller: 'VideoInfoController',
                    controllerAs: 'vm'
                })
                .state('videoSources', {
                    url: '/videoSources',
                    templateUrl: '/videoSources.html',
                    controller: 'VideoSourcesController',
                    controllerAs: 'vm'
                })
                .state('editVideoSource', {
                    url: '/editVideoSource/{id:int}',
                    parent: 'videoSources',
                    templateUrl: '/editVideoSource.html',
                    controller: 'EditVideoSourceController',
                    controllerAs: 'vm'
                })
                .state('play', {
                    url: '/play/{videoId:int}?{showVideoId:int}',
                    templateUrl: '/play.html',
                    controller: 'PlayController',
                    controllerAs: 'vm'
                })
                .state('search', {
                    url: '/search?q',
                    templateUrl: '/search.html',
                    controller: 'SearchController',
                    controllerAs: 'vm'
                })
                .state('metadataFetcher', {
                    url: '/metadataFetcher/{videoId:int}',
                    templateUrl: '/metadataFetcher.html',
                    controller: 'MetadataFetcherController',
                    controllerAs: 'vm'
                })
        }])

    .run(['$rootScope', '$state', '$stateParams', function ($rootScope, $state, $stateParams) {
        $rootScope.$state = $state;
        $rootScope.$stateParams = $stateParams;
    }])
angular.module('app').directive('loadMessage', [function () {
    'use strict';
    return {
        restrict: 'E',
        scope: {
            message: '='
        },
        template: '<span ng-show="message !== undefined"><span class="wait-small"></span>&nbsp;{{message}}</span>'
    };
}]);
angular.module('app').directive('confirm', [function() {
        return {
            restrict: 'A',
            link: function(scope, element, attributes, controller) {
                element.on('click', function() {
                    var message = scope.$eval(attributes.confirmMessage);
                    message = message? message: 'Are you sure you want to do that?';
                    //show the confirm modal
                    var confirmed = confirm(message);
                    if (confirmed) {
                        scope.$eval(attributes.confirm);
                    }
                });
            }
        }

    }]);
angular.module('app').directive('focus', ['$timeout', '$parse', function($timeout, $parse) {
        return {
            restrict: 'A',
            link: function($scope, element, attributes, controller) {
                $scope.$watch(function() {
                    return $scope.$eval(attributes.focus);
                }, function(focus) {
                    if (focus === true) {
                        $timeout(function() {
                            element[0].focus();
                            getter = $parse(attributes.focus);
                            //override the value with a false now that we have performed the focus
                            getter.assign($scope, false);
                        });
                    }
                });
            }
        }

    }]);
angular.module('app').service('admin', ['$http', '$q', '_', function($http, $q, _) {
        return {
            getServerVersionNumber: getServerVersionNumber,
            updateApplication: updateApplication
        };

        /**
         * Finds a poster and metadata for every video in the library that does not have one yet.
         * @returns {$q@call;defer.promise}
         */
        function getServerVersionNumber() {
            var deferred = $q.defer();
            $http.get('api/GetServerVersionNumber.php')
                    .success(function(result) {
                        deferred.resolve(result);
                    })
                    .error(function() {
                        deferred.reject();
                    });
            return deferred.promise;
        }

        /**
         * Checks for updates to this application and updates if there are any.
         * @returns {undefined}
         */
        function updateApplication() {
            var deferred = $q.defer();
            $http.get('api/Update.php')
                    .success(function(result) {
                        if (result.success === true) {
                            deferred.resolve(result);
                        } else {
                            deferred.reject(result);
                        }
                    })
                    .error(function(err) {
                        deferred.reject(err);
                    });
            return deferred.promise;
        }
    }]);
angular.module('app').service('api', ['$q', '$http', function ($q, $http) {
    return {
        generateLibrary: function () {
            return $q(function (resolve, reject) {
                $http.get('api/GenerateLibrary.php').success(function (result) {
                    if (result.success) {
                        resolve();
                    } else {
                        reject();
                    }
                }).error(function (e) {
                    reject(e);
                })
            });
        }
    };
}]);
angular.module('app').factory('debounce', ['$rootScope', function ($rootScope) {

        var registry = [];

        function registryIndexOf(identifier) {
            for (var i in registry) {
                var registryItem = registry[i];
                if (registryItem.identifier === identifier) {
                    return i;
                }
            }
            return -1;
        }

        function getFromRegistry(identifier) {
            var idx = registryIndexOf(identifier);
            return registry[idx];
        }

        function setRegistryItem(identifier, callback, expirationMilliseconds) {
            var registryItemIndex = registryIndexOf(identifier);
            var registryItem;
            //if there is no item in the registry with this identifier, make a new item
            if (registryItemIndex === -1) {
                registryItem = {
                    identifier: identifier,
                    callback: callback,
                    expirationDate: undefined
                };
            } else {
                //get the item from the registry
                registryItem = registry[registryItemIndex];
            }

            registryItem.expirationDate = new Date(Date.now() + expirationMilliseconds);

            if (registryItemIndex === -1) {
                registry.push(registryItem);
            }
            return registryItem;
        }

        function debounce(identifier, callback, expirationMilliseconds) {
            expirationMilliseconds = typeof expirationMilliseconds === 'number' ? expirationMilliseconds : 300;

            var registryItem = setRegistryItem(identifier, callback, expirationMilliseconds);


            //set a timeout and then see if the debounce has expired yet
            setTimeout(function () {
                if (registryItem.expirationDate < Date.now()) {
                    //the debounce has expired. call the callback
                    try {
                        $rootScope.$apply(function () {
                            registryItem.callback();
                        });
                    } catch (e) {
                    }
                    try {
                        //remove this item from the registry
                        registry.splice(registry.indexOf(registryItem), 1);
                    } catch (e) {

                    }
                } else {
                    //do nothing. something else has bumped the expiration date, so let that one's timeout handle it
                }
            }, expirationMilliseconds + 5);
        }
        return debounce;
    }
]);
angular.module('app').service('globals', [function() {
        return {
            pageTitle: 'PlumMediaCenter',
            hideNavbar: false,
            infiniteScrollPageSize: 25,
            //whenever the admin page launches a metadata fetch, keep track of its status here. 
            fetchMissingMetadataIsPending: false,
            generateLibraryIsPending: false,
            checkForUpdatesIsPending: false
        };
    }]);
angular.module('app').service('_', function(){
    return window._;
});
angular.module('app').service('notify', function() {
    return notify;
});

 function notify(message, type) {
        type = type ? type : 'warning';
        //if danger was provided, convert to error
        type = type === 'danger' ? 'error' : type;
        
        return new PNotify({
            title: '',
            text: message,
            styling: 'bootstrap3',
            type: type,
            buttons: {
                closer: true
            }
        });
    }
/**
 * Takes an image url and refreshes that image so that the browser cache can be refreshed
 * @param {type} param1
 * @param {type} param2
 */
angular.module('app').service('refreshImage', ['$q', function ($q) {
    return function (uri) {
        var deferred = $q.defer();
        //create an iframe
        var iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        //set the url for the image
        iframe.src = uri;

        //listen for the iframe to load or error
        iframe.addEventListener('load', onload, false);
        iframe.addEventListener('error', onerror, false);

        try {
            //add the iframe to the page
            document.body.appendChild(iframe);
        } catch (e) {
            onerror(e);
        }

        return deferred.promise;

        function onload() {
            cleanUp();
            deferred.resolve();
        }

        function onerror(e) {
            cleanUp()
            console.error('Error refreshing image', e);
            deferred.reject(e);
        }

        function cleanUp() {
            iframe.removeEventListener('load', onload, false);
            iframe.removeEventListener('error', onerror, false);
            document.body.removeChild(iframe);
        }

    }
}]);
angular.module('app').service('uniqueId', [function() {
        var counter = 0;
        return function() {
            counter++;
            return 'element-' + counter;
        }
    }]);
angular.module('app').service('util', ['_', function(_) {
        return {
            blankItemInPlace: blankItemInPlace
        };

        function blankItemInPlace(item) {
            if (_.isArray(item)) {
                while (item.length > 0) {
                    item.pop();
                }
            } else {
                for (var i in item) {
                    delete item[i];
                }
            }
        }
    }]);
angular.module('app').service('Video', ['$http', '$q', '_', function ($http, $q, _) {
    function Video() {

    }

    Video.search = function (searchTerm) {
        var deferred = $q.defer();
        $http.get('api/GetSearchResults.php', { params: { q: searchTerm } }).success(function (data) {
            deferred.resolve(data);
        }).error(function () {
            deferred.reject();
        });
        return deferred.promise;
    };

    Video.getAll = function () {
        return $q(function (resolve, reject) {
            $http.get('api/GetLibrary.php').success(function (data) {
                resolve(data);
            });
        });
    };

    Video.getById = function (id) {
        var deferred = $q.defer();
        if (!_.isNumber(id)) {
            deferred.reject();
        } else {
            $http.get('api/GetVideo.php?videoId=' + id).success(function (data) {
                deferred.resolve(data);
            }).error(function () {
                deferred.reject(data);
            });
        }
        return deferred.promise;
    };

    Video.getEpisodes = function (showId) {
        var deferred = $q.defer();
        $http.get('api/GetTvEpisodes.php?videoId=' + showId).success(function (data) {
            deferred.resolve(data);
        }).error(function () {
            deferred.reject();
        });
        return deferred.promise;
    };

    Video.getNextEpisode = function (showId) {
        var deferred = $q.defer();
        $http.get('api/GetNextEpisode.php?videoId=' + showId).success(function (data) {
            deferred.resolve(data);
        }).error(function () {
            deferred.reject();
        });
        return deferred.promise;
    };

    /**
     * Get how much percentage watched this video is
     * @param {type} videoId
     * @returns {$q@call;defer.promise}
     */
    Video.getProgressPercent = function (videoId) {
        var deferred = $q.defer();
        $http.get('api/GetVideoProgressPercent.php', { params: { videoId: videoId } })
            .success(function (result) {
                deferred.resolve(result.percent);
            })
            .error(deferred.reject);
        return deferred.promise;
    };

    /**
     * Get how much percentage watched each video is
     * @param {type} videoId
     * @returns {$q@call;defer.promise}
     */
    Video.getProgressPercentMultiple = function (videoIds) {
        videoIds = _.isArray(videoIds) ? videoIds : [];
        var deferred = $q.defer();
        $http.get('api/GetVideoProgressPercentMultiple.php', {
            params: {
                videoIds: videoIds.join(',')
            }
        }).success(function (result) {
            deferred.resolve(result);
        }).error(deferred.reject);
        return deferred.promise;
    };

    /**
     * Get the number of seconds into a video the current user is. 
     * @param {type} videoId
     * @returns {$q@call;defer.promise}
     */
    Video.getProgress = function (videoId) {
        var deferred = $q.defer();
        $http.get('api/GetVideoProgress.php', {
            params: {
                videoId: videoId
            }
        }).success(function (data) {
            deferred.resolve(data.startSeconds);
        }).error(function () {
            deferred.reject();
        });
        return deferred.promise;
    }

    Video.setProgress = function (videoId, seconds, isFinished) {
        isFinished = isFinished === true ? true : false;

        var deferred = $q.defer();
        $http.get('api/SetVideoProgress.php', {
            params: {
                videoId: videoId,
                seconds: seconds,
                finished: isFinished
            }
        }).success(function (data) {
            if (data.success) {
                deferred.resolve();
            } else {
                deferred.reject();
            }
        }).error(function () {
            deferred.reject();
        });
        return deferred.promise;
    }

    Video.getCounts = function () {
        var deferred = $q.defer();
        $http.get('api/GetVideoCounts.php').success(function (data) {
            deferred.resolve(data);
        }).error(function () {
            deferred.reject();
        });
        return deferred.promise;
    };

    Video.fetchMetadata = function (videoId, tmdbId) {
        var deferred = $q.defer();
        $http.get('api/FetchVideoMetadata.php', { params: { videoId: videoId, tmdbId: tmdbId } }).success(function (data) {
            deferred.resolve(data);
        }).error(function () {
            deferred.reject();
        });
        return deferred.promise;
    };

    Video.getMetadataSearchResultsByTitle = function (mediaType, title) {
        var deferred = $q.defer();
        $http.get('api/GetMetadataSearchResults.php', {
            params: {
                mediaType: mediaType,
                title: title
            }
        }).success(function (data) {
            deferred.resolve(data);
        }).error(function () {
            deferred.reject();
        });
        return deferred.promise;
    }

    Video.scanForNewMedia = function (videoId) {
        var deferred = $q.defer();
        $http.get('api/ScanForNewMedia.php', {
            params: {
                videoId: videoId
            }
        }).then(function (result) {
            deferred.resolve(result.data);
        }, function (err) {
            deferred.reject(err);
        });
        return deferred.promise;
    }

    Video.getMetadataSearchResultsBytmdbId = function (mediaType, tmdbId) {
        var deferred = $q.defer();
        $http.get('api/GetMetadataSearchResults.php', {
            params: {
                mediaType: mediaType,
                tmdbId: tmdbId
            }
        }).success(function (data) {
            deferred.resolve(data);
        }).error(function () {
            deferred.reject();
        });
        return deferred.promise;
    }

    Video.getPathInfo = function (videoId) {
        var deferred = $q.defer();
        $http.get('api/GetVideoPathInfo.php?videoId=' + videoId)
            .success(function (video) {
                deferred.resolve(video);
            })
            .error(function () {
                deferred.reject();
            });
        return deferred.promise;
    }

    Video.getShowFromEpisodeId = function (episodeId) {
        var deferred = $q.defer();
        $http.get('api/GetTvShowByEpisodeId.php?videoId=' + episodeId)
            .success(function (video) {
                deferred.resolve(video);
            })
            .error(function () {
                deferred.reject();
            });
        return deferred.promise;
    }

    /**
     * Finds a poster and metadata for every video in the library that does not have one yet.
     * @returns {$q@call;defer.promise}
     */
    Video.fetchMissingMetadata = function () {
        var deferred = $q.defer();
        $http.get('api/FetchMissingMetadataAndPosters.php')
            .success(function (result) {
                deferred.resolve(result);
            })
            .error(function () {
                deferred.reject();
            });
        return deferred.promise;
    }

    Video.addNewMediaItem = function (videoSourceId, newMediaItemPath) {
        return $http.get('api/AddNewMediaItem.php', { params: { videoSourceId: videoSourceId, path: newMediaItemPath } }).then(function (result) {
            return result.data;
        }, function (error) {
            return error;
        });
    };


    Video.getCategoryNames = function () {
        return $http.get('api/GetCategoryNames.php').then(function (result) {
            return result.data;
        }, function (error) {
            return error;
        });
    };

    Video.getCategories = function (names) {
        names = typeof names !== 'string' && typeof names.length === 'number' ? names : [];
        properties = ['videoId', 'posterModifiedDate', 'title', 'hdPosterUrl'];

        return $http.get('api/GetCategories.php', {
            params: {
                names: names.join(','),
                properties: properties ? properties.join(',') : undefined
            }
        }).then(function (result) {
            var videos = result.data.videos;
            var categories = result.data.categories;

            //categories only come with a list of video ids, so assemble an array of videos based on the video id list and the video map
            for (var i = 0; i < categories.length; i++) {
                var category = categories[i];
                category.videos = [];
                for (var j = 0; j < category.videoIds.length; j++) {
                    var videoId = category.videoIds[j];
                    var video = videos[videoId];
                    if (video) {
                        category.videos.push(video);
                    }
                }
                delete category.videoIds;
            }
            return categories;
        }, function (error) {
            return error;
        });
    };

    Video.processVideo = function (videoId) {
        return $http.get('api/ProcessVideo.php', { params: { videoId: videoId } }).then(function (response) {
            var result = response.data;
            if (result.success === true) {
                return result;
            } else {
                return $q.reject(result);
            }
        });
    };

    Video.addToList = function (listName, videoIds) {
        return $http.get('api/AddToList.php', { params: { videoIds: videoIds, listName: listName } });
    };

    Video.removeFromList = function (listName, videoIds) {
        return $http.get('api/RemoveFromList.php', { params: { videoIds: videoIds, listName: listName } });
    };

    Video.isInList = function (listName, videoId) {
        return $http.get('api/IsInList.php', { params: { videoId: videoId, listName: listName } }).then(function (response) {
            return response.data;
        });
    };

    Video.getListInfo = function (videoId) {
        return $http.get('api/GetVideoListInfo.php', { params: { videoId: videoId } }).then(function (response) {
            return response.data;
        });
    };
    return Video;
}]);
angular.module('app').service('VideoSource', ['$http', '$q', function($http, $q) {
        function VideoSource() {

        }

        VideoSource.getAll = function() {
            var deferred = $q.defer();
            $http.get('api/GetVideoSources.php').success(function(data) {
                deferred.resolve(data);
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        };

        VideoSource.getById = function(id) {
            var deferred = $q.defer();
            $http.get('api/GetVideoSourceById.php?id=' + id).success(function(data) {
                deferred.resolve(data);
            }).error(function() {
                deferred.reject();
            });
            return deferred.promise;
        };

        VideoSource.save = function(videoSource) {
            return $q(function(resolve, reject) {
                $http.post('api/PostVideoSource.php', videoSource).then(function(result) {
                    resolve(result.data);
                }, reject);
            });
        };

        VideoSource.deleteById = function(id) {
            return $q(function(resolve, reject) {
                $http.delete('api/DeleteVideoSource.php', {data: {id: id}}).then(function(result) {
                    resolve(result.data);
                }, reject);
            });
        };

        return VideoSource;
    }]);
angular.module('app').controller('BaseController', ['globals',function(globals) {
        var vm = angular.extend(this, {
            globals: globals
        });
        
    }]);
angular.module('app').directive('pathExistsValidator', ['$http', '$q', function($http, $q) {
    return { 
        require: 'ngModel',
        link: function(scope, element, attrs, ngModel) {
            ngModel.$asyncValidators.pathExists = function(modelValue, viewValue) {
                var value = modelValue || viewValue;
                return $http.get('api/GetPathExistsOnServer.php', {params: {path: value}}).then(
                        function(response) {
                            if (!response.data.exists === true) {
                                return $q.reject(response.data.errorMessage);
                            }
                            return true;
                        }
                );
            };
        }
    };
}]);
angular.module('app').directive('urlExistsValidator', ['$http', '$q', function ($http, $q) {
    return {
        require: 'ngModel',
        link: function (scope, element, attrs, ngModel) {
            ngModel.$asyncValidators.urlExists = function (modelValue, viewValue) {
                var value = modelValue || viewValue;
                return $http.get('api/GetUrlExists.php', { params: { url: value } }).then(function (response) {
                    if (!response.data.exists === true) {
                        return $q.reject(response.data.errorMessage);
                    }
                    return true;
                }, function (err) {
                    return $q.reject(err);
                });
            };
        }
    };
}]);
angular.module('app').directive('categoryScroller', ['$window', '$timeout', 'debounce', function ($window, $timeout, debounce) {
        var id = 0;
        return {
            restrict: 'E',
            controller: ['$scope', 'Video', Controller],
            controllerAs: 'vm',
            bindToController: true,
            templateUrl: '/categoryScroller.html',
            scope: {
                category: '=?',
                categoryName: '=?'
            },
            link: function ($scope, element, attributes, vm) {
                var myId = id++;
                //anytime the window changes size, determine the new width of this element
                angular.element($window).bind('resize', function () {
                    calculateElementWidth();
                });

                function calculateElementWidth() {
                    debounce(myId, function () {
                        if(element) {
                            var rect = element[0].getBoundingClientRect();
                            vm.width = rect.width;
                        }
                    }, 100);
                }

                //anytime the width changes, calculate the size of the first video tile in the list
                $scope.$watchCollection(function () {
                    return vm.width;
                }, function (width) {
                    getTileWidth();
                });

                function getTileWidth() {
                    //get the first video tile
                    var videoTile = element[0].querySelector('video-tile');
                    if(videoTile) {
                        var rect = videoTile.getBoundingClientRect();
                        vm.videoTileWidth = rect.width;
                        vm.videoTileHeight = rect.height;
                    }
                }
                //the first time the length of the video list is greater than zero, recalculate the tile width
                $scope.$watch(function () {
                    return vm.category && vm.category.videos && vm.category.videos.length ? true : false;
                }, function (newValue, oldValue) {
                    if (newValue) {
                        getTileWidth();
                    }
                });

                calculateElementWidth();

            }
        };

        function Controller($scope, Video) {
            var vm = angular.extend(this, {
                category: this.category,
                direction: undefined,
                width: 0,
                videoTileWidth: 0,
                videoTileHeight: 0,
                visibleVideoTileCount: 0,
                visibleVideos: [],
                leftmostVideoIndex: 0,
                //api
                calculateVisibleVideoTileCount: calculateVisibleVideoTileCount,
                getLocationText: getLocationText,
                populateVisibleVideos: populateVisibleVideos,
                pageLeft: pageLeft,
                pageRight: pageRight,
                showPageLeft: showPageLeft,
                showPageRight: showPageRight,
                videoCount: videoCount
            });

            //anytime the categoryName changes, reload the video list
            $scope.$watch(function () {
                return vm.categoryName;
            }, function (newValue, oldValue) {
                if (newValue) {
                    Video.getCategories([newValue]).then(function (categories) {
                        vm.category = categories[0];
                        populateVisibleVideos();
                    });
                }
            });

            $scope.$watch(function () {
                return vm.videoTileWidth;
            }, function () {
                vm.calculateVisibleVideoTileCount();
            });
            $scope.$watch(function () {
                return vm.width;
            }, function () {
                vm.calculateVisibleVideoTileCount();
            });

            $scope.$watch(function () {
                return vm.visibleVideoTileCount;
            }, function (newVisibleVideoTileCount, oldVisibleVideoTileCount) {
                populateVisibleVideos();
            });

            function populateVisibleVideos() {
                if (vm.visibleVideoTileCount < 1) {
                    vm.visibleVideos = [];
                    return;
                }
                if (!vm.category) {
                    return;
                }
                //if the list of videos is smaller than the maximum displayable, then just add all of them
                if (vm.videoCount() <= vm.visibleVideoTileCount) {
                    vm.visibleVideos = vm.category.videos.slice(0);
                } else {
                    //find the index of the leftmost video
                    var endIndex = vm.leftmostVideoIndex + vm.visibleVideoTileCount;
                    vm.visibleVideos = [];
                    for (var i = vm.leftmostVideoIndex; i < endIndex; i++) {
                        var index = i % vm.videoCount();
                        var video = vm.category.videos[index];
                        if (video) {
                            vm.visibleVideos.push(video);
                        }
                    }
                }
            }

            function calculateVisibleVideoTileCount() {
                //60px for the left and right navigation buttons
                var num = (vm.width - 60) / vm.videoTileWidth;
                if (!isFinite(num)) {
                    num = 0;
                } else {
                    num = Math.floor(num);
                }
                vm.visibleVideoTileCount = num;
            }

            function pageLeft() {
                var newLeftmostIndex = vm.leftmostVideoIndex - vm.visibleVideoTileCount;
                if (newLeftmostIndex < 0) {
                    newLeftmostIndex = 0;
                }
                vm.leftmostVideoIndex = newLeftmostIndex;
                vm.populateVisibleVideos();
                vm.direction = 'left';
            }

            function pageRight() {
                var newLeftmostIndex = vm.leftmostVideoIndex + vm.visibleVideoTileCount;
                var maxLeftmostIndex = (vm.videoCount() + 1) - vm.visibleVideoTileCount;
                if (newLeftmostIndex > maxLeftmostIndex) {
                    newLeftmostIndex = maxLeftmostIndex;
                }
                vm.leftmostVideoIndex = newLeftmostIndex;
                console.log('leftmost idx' + vm.leftmostVideoIndex);
                vm.populateVisibleVideos();
                vm.direction = 'right';
            }

            function videoCount() {
                return vm.category && vm.category.videos ? vm.category.videos.length : 0;
            }

            function showPageLeft() {
                return vm.leftmostVideoIndex > 0
            }

            function showPageRight() {
                var maxLeftmostIndex = (vm.videoCount() - 1) - vm.visibleVideoTileCount;
                return vm.leftmostVideoIndex < maxLeftmostIndex;
            }

            function getLocationText() {
                return "";
                var firstNumber = vm.leftmostVideoIndex = 0 ? 0 : (vm.leftmostVideoIndex + 1);
                var text = firstNumber + '-' + (vm.leftmostVideoIndex + vm.visibleVideos.length) + ' of ' + vm.videoCount();
                return text;
            }
        }
    }
]);
angular.module('app').directive('categoryScrollerCollection', [function () {
        return {
            restrict: 'E',
            controller: ['Video', Controller],
            controllerAs: 'vm',
            bindToController: true,
            templateUrl: '/categoryScrollerCollection.html',
            link: function () {

            }
        };

        function Controller(Video) {
            var vm = angular.extend(this, {
                categories: undefined
            });
            //get all of the category names
            Video.getCategoryNames().then(function (names) {
                 vm.categoryNames = names;
            });
        }
    }
]);
angular.module('app').directive('episode', [function () {
        return {
            restrict: 'E',
            scope: {
                episode: '=',
                selected: '=?'
            },
            controller: Controller,
            controllerAs: 'vm',
            bindToController: true,
            link: function($scope, element, attributes, vm){
                
            },
            templateUrl: '/episode.html'
        };
        
        function Controller(){
            var vm = angular.extend(this, {
                //episode
            }, this);
            
            var maxTitleLength = 17;
            //truncate the title 
            
            vm.title = vm.episode.title;
            if(vm.episode.title.length > maxTitleLength){
                vm.title = vm.episode.title.substring(0, maxTitleLength) + '...';
            }

            //calculate the runtime text
            if(typeof vm.episode.runtime === 'number' && vm.episode.runtime > -1){
                var runtimeMinutes = parseInt(vm.episode.runtime / 60);
                vm.runtimeText = '(' + runtimeMinutes + ' min)';
            }   
        }
    }
]);
angular.module('app').directive('navbar', ['$state', function ($state) {
    return {
        restrict: 'E',
        controller: ['$state', Controller],
        controllerAs: 'vm',
        bindToController: true,
        templateUrl: '/navbar.html',
        scope: {
        }
    };

    function Controller($state) {
        var vm = angular.extend(this, {
            searchTerm: undefined,
            navbarIsOpen: false,
            //api
            search: search,
            hideNavbar: hideNavbar,
            toggleNavbar: toggleNavbar
        });
        function search() {
            if (vm.searchTerm && vm.searchTerm.trim().length > 0) {
                $state.go('search', { q: vm.searchTerm });
                vm.searchTerm = undefined;
                hideNavbar();
            }
        }

        function showNavbar() {
            vm.navbarIsOpen = true;
        }

        function hideNavbar() {
            vm.navbarIsOpen = false;
        }

        function toggleNavbar() {
            vm.navbarIsOpen ? hideNavbar() : showNavbar();
        }
    }
}]);
angular.module('app').directive('videoTile', [function () {
        return {
            restrict: 'E',
            controllerAs: 'vm',
            controller: [Controller],
            bindToController: true,
            scope: {
                video: '='
            },
            templateUrl: '/videoTile.html'
        }

        function Controller() {
            var vm = this;
            //if the video has no poster, use the blank one
            if (vm.video && !vm.video.hdPosterUrl) {
                if (vm.video.mediaType === 'Movie') {
                    vm.video.hdPosterUrl = 'assets/img/posters/BlankPoster.hd.jpg'
                }
            }
        }
    }]);
angular.module('app').directive('videoPlayer', [function () {
    return {
        restrict: 'E',
        replace: true,
        controllerAs: 'vm',
        controller: ['$scope', 'uniqueId', 'Video', 'globals', Controller],
        bindToController: true,
        scope: {
            videoId: '='
        },
        link: function (scope, element, attributes, vm) {
            vm.element = element;
        }
    };
    function Controller($scope, uniqueId, Video, globals) {
        var vm = this;

        Video.getById(vm.videoId).then(function (video) {
            //get the current progress of this video.
            Video.getProgress(vm.videoId).then(function (seconds) {
                vm.video = video;
                addVideoElement(video, seconds);
            });
        });

        function addVideoElement(video, startSeconds) {
            var id = uniqueId();
            var html = '\
                <video id="' + id + '" class="video-js" vjs-big-play-centered controls style="width:100%;height:100%;"\
                    poster="' + video.hdPosterUrl + '" data-setup=\'{"preload": "auto"}\'>\
                    <source src="' + video.url + '" type="video/mp4" \>\
                    <p class="vjs-no-js">\
                        To view this video please enable JavaScript, and consider upgrading to a web browser that\
                        <a href="http://videojs.com/html5-video-support/" target="_blank">supports HTML5 video</a>\
                    </p>\
                 </video>';
            vm.element.append(html);
            //initialize the video player
            var player = videojs(id);

            //register events
            player.ready(function () {
                this.currentTime(startSeconds);
                this.on('timeupdate', function () {
                    updateTime(this.currentTime());
                })
                //when the video finishes, mark it as complete
                this.on('ended', function () {
                    Video.setProgress(vm.video.videoId, -1, true);
                })
            });
        }

        var lastUpdateTime = new Date();
        function updateTime(currentSeconds) {
            var now = new Date();
            //if it has been at least n seconds since the last time save, save now
            if (now.getTime() - lastUpdateTime.getTime() > 2000) {
                lastUpdateTime = now;
                Video.setProgress(vm.video.videoId, currentSeconds);
            }
        }

        $scope.$on("$destroy", function () {
            globals.hideNavbar = false;
        });
    }

}]);
angular.module('app').controller('AddNewMediaItemController', ['Video', 'globals', 'VideoSource', 'notify', function (Video, globals, VideoSource, notify) {
        globals.title = 'Add new media item';

        var vm = angular.extend(this, {
            //properties
            videoSources: [],
            newMediaItem: {},
            loadMessage: undefined,
            //api
            addNewMediaItem: addNewMediaItem
        });

        VideoSource.getAll().then(function (videoSources) {
            vm.videoSources = videoSources;
        });

        function addNewMediaItem() {
            vm.loadMessage = 'Scanning for new media';
            Video.addNewMediaItem(vm.newMediaItem.videoSourceId, vm.newMediaItem.path).then(function (result) {
                if (!result || result.success !== true) {
                    throw new Error('An error occurred' + JSON.stringify(result));
                }
                if (result && result.newVideoIds && result.newVideoIds.length > 0) {
                    notify(result.newVideoIds.length + ' new media ' + (result.newVideoIds.length === 1 ? 'item was' : 'items were') + ' successfully added', 'success');
                } else {
                    notify('No new media items were found');
                }
            }, function (error) {
                notify(error.message, 'danger');
            }).finally(function () {
                vm.loadMessage = undefined;
            });
        }
    }]);
angular.module('app').controller('AdminController', ['$timeout', '$window', 'globals', 'api', 'notify', 'Video', 'admin',
    function ($timeout, $window, globals, api, notify, Video, admin) {
        globals.title = 'Admin';

        var vm = angular.extend(this, {
            //properties
            serverVersionNumber: undefined,
            //api
            fetchMissingMetadata: fetchMissingMetadata,
            generateLibrary: generateLibrary,
            updateApplication: updateApplication
        });


        getVideoCounts();
        getServerVersionNumber();

        function generateLibrary() {
            var n = notify('Generating library', 'info');
            globals.generateLibraryIsPending = true;
            api.generateLibrary().then(function () {
                notify('Library has been generated', 'success');
            }).catch(function (err) {
                notify('There was an error generating the library: "' + err.message + '"', 'danger');
            }).finally(function () {
                globals.generateLibraryIsPending = false;
                getVideoCounts();
            });
        }

        function getServerVersionNumber() {
            admin.getServerVersionNumber().then(function (version) {
                vm.serverVersionNumber = version;
            });
        }
        function getVideoCounts() {
            Video.getCounts().then(function (videoCounts) {
                vm.videoCounts = videoCounts;
            });
        }

        function fetchMissingMetadata() {
            globals.fetchMissingMetadataIsPending = true;
            notify('Fetching missing metadata', 'info');
            Video.fetchMissingMetadata().then(function () {
                notify('Finished fetching missing metata for videos', 'success');
            }, function () {
                notify('There was an error fetching missing metadata', 'error');
            }).finally(function () {
                globals.fetchMissingMetadataIsPending = false;
            });
        }

        function updateApplication() {
            globals.checkForUpdatesIsPending = true;
            notify('Checking for updates. Please wait until this operation has completed', 'info');
            admin.updateApplication().then(function (result) {
                if (result.updateWasApplied) {
                    notify('Application has been updated. Reloading page.', 'success');
                    $timeout(function () {
                        $window.location.reload();
                    }, 4000);
                } else {
                    notify('No updates were found', 'success');
                }
            }, function () {
                notify('Unable to check and install updates', 'error');
            }).finally(function () {
                globals.checkForUpdatesIsPending = false;
            });
        }
    }]);
angular.module('app').controller('CategoriesController', ['Video', 'globals', '$stateParams',
    function (Video, globals, $stateParams) {
        globals.title = 'Add new media item';

        var vm = angular.extend(this, {
            //properties
            categoryName: $stateParams.categoryName,
            loadMessage: undefined,
            category: undefined,
        });

        (function constructor() {
            vm.loadMessage = 'Loading videos';
            Video.getCategories([vm.categoryName]).then(function (categories) {
                vm.category = categories[0];
            }).finally(function () {
                vm.loadMessage = undefined;
            });
        })();
    }
]);
angular.module('app').controller('EditVideoSourceController', [
    '$scope', 'globals', 'VideoSource', '$state', '$stateParams', 'enums',
    function ($scope, globals, VideoSource, $state, $stateParams, enums) {
        var vm = angular.extend(this, {
            isLoading: false,
            isSaving: false,
            //properties
            originalVideoSource: undefined,
            videoSource: {
                securityType: enums.securityType.public,
            },
            //api
            reset: reset,
            save: save,
            sayHi: function () {
                alert('hi');
            },
            isValidatingUrl: () => {
                return vm.form.baseUrl.$pending && vm.form.baseUrl.$pending.urlExists;
            }
        });

        globals.title = 'Edit Video Source';
        vm.originalVideoSource = angular.copy(vm.videoSource);
        loadVideoSource();

        function loadVideoSource() {
            //if an id was provided, go look up the settings for that videoSource
            if ($stateParams.id && $stateParams.id > 0) {
                vm.isLoading = true;
                VideoSource.getById($stateParams.id).then(function (videoSource) {
                    vm.videoSource = videoSource;
                    vm.originalVideoSource = angular.copy(videoSource);
                }).finally(function () {
                    vm.isLoading = false;
                });
            }
        }

        function reset() {
            vm.videoSource = vm.originalVideoSource;
            vm.form.setPristine(true);
        }

        function save() {
            vm.isSaving = true;
            VideoSource.save(vm.videoSource).then(function (videoSource) {
                vm.isSaving = false;
                loadVideoSource();
                notify('Saved video source', 'success');
                $state.go('videoSources', {}, { reload: true });
            }, function () {
                //handle the error
                vm.isSaving = false;
            });
        }
    }]);
angular.module('app').controller('FetchByTitleController', ['$stateParams',
    function($stateParams) {
        var vm = angular.extend(this, {
            //properties
            title: undefined
                    //api

        });

        vm.title = $stateParams.title;

    }]);
angular.module('app').controller('HomeController', ['globals', 'Video', function(globals, Video) {
        var vm = angular.extend(this, {
            allVideos: [],
            currentlyLoadedVideos: [],
            //api
            loadMore: loadMore
        });
        globals.title = 'Home';

//        Video.getAll().then(function(videos) {
//            vm.allVideos = videos;
//        });

        function loadMore() {
            var numberToLoad = globals.infiniteScrollPageSize;
            var beginIndex = vm.currentlyLoadedVideos.length;
            var endIndex = beginIndex + numberToLoad;
            //if the end index is larger than the list of all videos, change the end index to the length of the list of all videos
            endIndex = endIndex > vm.allVideos.length ? vm.allVideos.length : endIndex;

            for (var i = beginIndex; i < endIndex; i++) {
                vm.currentlyLoadedVideos.push(vm.allVideos[i]);
            }
        }

    }]);
angular.module('app').controller('MetadataFetcherController', ['$scope', '$q', 'globals', 'refreshImage', 'Video', '$state', '$stateParams', 'notify', 'enums',
    function ($scope, $q, globals, refreshImage, Video, $state, $stateParams, notify, enums) {
        globals.title = 'Fetch Metadata';
        var vm = angular.extend(this, {
            searchByOptions: {
                tmdbId: 'tmdbId',
                title: 'title'
            },
            videoId: $stateParams.videoId,
            searchBy: 'tmdbId',
            isSearching: false,
            metadataIsBeingFetched: false,
            textboxLabel: undefined,
            //this is the value (title, tmdbId) to use to search for the metadata
            searchValue: undefined,
            searchResults: undefined,
            video: {},
            //api
            search: search,
            calculateTextboxLabel: calculateTextboxLabel,
            fetchMetadataBytmdbId: fetchMetadataBytmdbId
        });

        function constructor() {
            //load the video
            Video.getById(vm.videoId).then(function (video) {
                angular.extend(vm.video, video);
                searchByChanged()
                //run the first search right away, since that's probably what the user wants to do anyway...
                search();
            });

            Video.getPathInfo(vm.videoId).then(function (video) {
                angular.extend(vm.video, video);
            });

            $scope.$watch('vm.searchBy', searchByChanged);

            $scope.$watch('vm.video', vm.calculateTextboxLabel);
        }

        function searchByChanged() {
            vm.calculateTextboxLabel();
            if (vm.searchBy === vm.searchByOptions.title) {
                vm.searchValue = vm.video.title;
            } else {
                vm.searchValue = '';
            }
        }

        function calculateTextboxLabel() {
            vm.textboxLabel = undefined;

            if (!vm.video) {
                return;
            }
            if (vm.searchBy === vm.searchByOptions.title) {
                vm.textboxLabel = 'Title';
            } else {
                vm.textboxLabel = vm.video.mediaType === enums.mediaTypeMovie ? 'TMDB ID' : 'TVDB ID';
            }
        }

        function search() {
            vm.isSearching = true;
            var promise;
            if (vm.searchBy === vm.searchByOptions.title) {
                promise = Video.getMetadataSearchResultsByTitle(vm.video.mediaType, vm.searchValue);
            } else {
                promise = Video.getMetadataSearchResultsBytmdbId(vm.video.mediaType, vm.searchValue);
            }
            promise.then(function (searchResults) {
                vm.metadataResults = searchResults;
                vm.isSearching = false;
            });
        }

        function fetchMetadataBytmdbId(tmdbId) {
            vm.metadataIsBeingFetched = true;
            Video.fetchMetadata(vm.video.videoId, tmdbId).then(function () {
                return Video.getById(vm.video.videoId);
            }).then(function (video) {
                //refresh the posters so that when we go back to videoInfo, the poster cache has been cleared
                return refreshImage(video.sdPosterUrl).then(function () {
                    return refreshImage(video.hdPosterUrl);
                }).then(function () {
                    //there was an issue getting the browser to refresh the cached images. try reloading the page (after we have 
                    //navigated to the videoInfo page)
                    setTimeout(function () {
                        window.location.reload();
                    }, 200);
                    return undefined;
                }, function (err) {
                    return $q.reject(err);
                });
            }).then(function () {
                vm.metadataResults = undefined;
                vm.metadataIsBeingFetched = false;

                notify('Updated video with selected metadata', 'success');
                $state.go('videoInfo', { videoId: vm.videoId });
            })['catch'](function (err) {
                vm.metadataIsBeingFetched = false;
                notify('There was an error fetching metadata for the video you selected: ' + err, 'error');
            })
        }

        constructor();
    }
]);
angular.module('app').controller('PlayController', ['Video', '$scope', 'globals', '$stateParams', 'notify',
    function (Video, $scope, globals, $stateParams, notify) {
        globals.title = 'Play';
        globals.hideNavbar = true;

        var vm = angular.extend(this, {
            videoId: $stateParams.videoId,
            showVideoId: $stateParams.showVideoId
        });

       

        $scope.$on("$destroy", function () {
            globals.hideNavbar = false;
        });
    }]);
angular.module('app').controller('SearchController', ['globals', 'Video', '$stateParams', function(globals, Video, $stateParams) {
        var vm = angular.extend(this, {
            allVideos: null,
            currentlyLoadedVideos: [],
            searchTerm: $stateParams.q,
            //api
            loadMore: loadMore
        });

        globals.title = 'Home';
        var searchTerm = $stateParams.q;

        Video.search(searchTerm).then(function(videos) {
            vm.allVideos = videos;
        });


        function loadMore() {
            var numberToLoad = globals.infiniteScrollPageSize;
            var beginIndex = vm.currentlyLoadedVideos.length;
            var endIndex = beginIndex + numberToLoad;
            //if the end index is larger than the list of all videos, change the end index to the length of the list of all videos
            endIndex = endIndex > vm.allVideos.length ? vm.allVideos.length : endIndex;

            for (var i = beginIndex; i < endIndex; i++) {
                var video = vm.allVideos[i];
                vm.currentlyLoadedVideos.push(video);
            }
        }

    }]);
angular.module('app').controller('VideoInfoController', ['$scope', '$timeout', 'globals', 'Video', '$state', '$stateParams', 'enums', 'notify',
    function ($scope, $timeout, globals, Video, $state, $stateParams, enums, notify) {
        var vm = angular.extend(this, {
            listInfo: undefined,
            progressPercent: 0,
            preventCache: $stateParams.preventCache,
            episodes: undefined,
            nextEpisode: undefined,
            videoId: $stateParams.videoId,
            loadMessage: undefined,
            isProcessingVideo: false,
            isInMyList: undefined,
            //api
            getProgressPercentType: getProgressPercentType,
            runtimeMinutes: runtimeMinutes,
            navigateToShow: navigateToShow,
            scanForNewMedia: scanForNewMedia,
            playIsDisabled: playIsDisabled,
            processVideo: processVideo,
            toggleList: toggleList
        });
        globals.title = 'VideoInfo';

        $scope.$watch('vm.episodes', fetchAllEpisodePercentWatched);

        loadListInfo();

        //load the video by id
        Video.getById(vm.videoId).then(function (video) {
            vm.video = video;

            if (vm.video.mediaType === enums.mediaType.show) {
                //get all of the episodes for this show
                Video.getEpisodes(vm.video.videoId).then(function (episodes) {
                    vm.episodes = episodes;
                    //find the next episode that should be watched
                }).then(function () {
                    return Video.getNextEpisode(vm.video.videoId);
                    //select the episode in our local list of episodes that matches the next episode
                }).then(function (nextEpisode) {
                    vm.nextEpisode = _.where(vm.episodes, { videoId: nextEpisode.videoId })[0];
                    //figure out how much of this episode has been watched
                }).then(function () {
                    return Video.getProgressPercent(vm.nextEpisode.videoId);
                    //save the percentWatched to the episode
                }).then(function (percent) {
                    vm.nextEpisode.percentWatched = percent;
                });
            }

            //load the progress of this video
            Video.getProgressPercent(vm.video.videoId).then(function (percent) {
                vm.progressPercent = percent;
            });
        });

        function processVideo() {
            vm.isProcessingVideo = true;
            Video.processVideo(vm.videoId).then(function () {
                notify('Video was processed', 'success');
            }, function () {
                notify('There was a problem processing the video', 'error');
            }).finally(function () {
                vm.isProcessingVideo = false;
            });
        }

        function runtimeMinutes() {
            if (vm.video && vm.video.runtime) {
                return Math.ceil(vm.video.runtime / 60);
            } else {
                return null;
            }
        }

        function playIsDisabled() {
            if (!vm.video || (vm.video.mediaType === enums.mediaType.show && !vm.nextEpisode)) {
                return true;
            } else {
                return false;
            }
        }

        /**
         * Grabs the percent watched for every episode
         * @returns {undefined}
         */
        function fetchAllEpisodePercentWatched() {
            var videoIds = _.pluck(vm.episodes, 'videoId');
            Video.getProgressPercentMultiple(videoIds).then(function (percentObjects) {
                for (var i in percentObjects) {
                    var percentObj = percentObjects[i];
                    var episode = _.where(vm.episodes, { videoId: percentObj.videoId })[0];
                    if (episode) {
                        episode.percentWatched = percentObj.percent;
                    }
                }
            });
        }

        function getProgressPercentType() {
            if (vm.progressPercent < 40) {
                return 'danger';
            } else if (vm.progressPercent < 99) {
                return 'warning';
            } else if (vm.progressPercent < 101) {
                return 'success';
            }
        }

        function scanForNewMedia() {
            vm.loadMessage = 'Scanning for new media';
            Video.scanForNewMedia(vm.videoId).then(function (result) {
                if (!result || result.success !== true) {
                    throw new Error('An error occurred' + JSON.stringify(result));
                }
                if (result && result.newVideoIds && result.newVideoIds.length > 0) {
                    notify(result.newVideoIds.length + ' new media ' + (result.newVideoIds.length === 1 ? 'item was' : 'items were') + ' successfully added', 'success');
                    vm.loadMessage = 'Refreshing page';
                    return $timeout(function () {
                        //reload the current state to get any new videos
                        $state.reload($state.current.name);
                        vm.loadMessage = undefined;
                    }, 1500);
                } else {
                    notify('No new media items were found');
                }

            }, function (error) {
                notify(error.message, 'danger');
            }).finally(function () {
                vm.loadMessage = undefined;
            });
        }

        function navigateToShow() {
            Video.getShowFromEpisodeId(vm.videoId).then(function (show) {
                $state.go('videoInfo', { videoId: show.videoId });
            });
        }

        function loadListInfo() {
            return Video.getListInfo(vm.videoId).then((value) => {
                vm.listInfo = value;
            });
        }

        function toggleList(listName) {
            var promise;
            if (this.listInfo[listName]) {
                promise = Video.removeFromList(listName, vm.videoId);
            } else {
                promise = Video.addToList(listName, vm.videoId);
            }
            //switch the value locally for now so the user sees an instant change
            this.listInfo[listName] = !this.listInfo[listName];
            return promise.then(function () {
                return loadListInfo();
            }, console.error);
        }
    }
]);
angular.module('app').controller('VideoSourcesController', ['globals', 'VideoSource', 'notify',
    function(globals, VideoSource, notify) {
        var vm = this;
        vm.editIsVisible = false;
        vm.deleteVideoSource = deleteVideoSource;
        vm.refresh = loadVideoSources;

        globals.title = 'Video Sources';
        loadVideoSources();
        
        function loadVideoSources() {
            VideoSource.getAll().then(function(videoSources) {
                vm.videoSources = videoSources;
            });
        }

        function deleteVideoSource(id) {
            VideoSource.deleteById(id).then(loadVideoSources);
        }
    }]);
//# sourceMappingURL=app.min.js.map
